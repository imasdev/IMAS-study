# CHAPTER 14 자바 모듈 시스템

발표자: 남채린
스터디일정: 2022/06/09
주차별: 8주차
참여자: 남채린, 이수환, 이승민, 장현준

## 모듈화란? 모듈 시스템은 어떤 문제를 해결할 수 있는가?

자바 언어 설계자들의 목표 

⇒ 소프트웨어 아키텍처 즉 고수준에서 기반 코드를 바꿔야 할 때 생산성을 높일 수 있는 소프트웨어 프로젝트가 필요하다.

추론하기 쉬운 소프트웨어를 만드는 데 도움을 주는 **관심사 분리**와 **정보 은닉** 원칙

- 관심사 분리 SoC(Separation of concerns)
    - 컴퓨터 프로그램을 고유의 기능으로 나누는 동작을 권장하는 원칙이다.
    
    - 기능을 모듈이라는 각각의 부분 즉, 서로 거의 겹치지 않는 코드 그룹으로 분리할 수 있다.
        
        = 클래스를 그룹화한 모듈을 이용해 애플리케이션 클래스 간의 관계를 시각적으로 보여줄 수 있다.
        
    - SoC 원칙은 모델, 뷰, 컨트롤러 같은 아키텍처 관점 그리고 복구 기법을 비즈니스 로직과 분리하는 등의 하위 수준 접근 등의 상황에 유용하다.
    
    <aside>
    💡 장점
    - 개별 기능을 따로 작업할 수 있으므로 팀이 쉽게 협업할 수 있다.
    - 개별 부분을 재사용하기 쉽다.
    - 전체 시스템을 쉽게 유지보수할 수 있다.
    
    </aside>
    
- 정보 은닉
    - 세부 구현을 숨기도록 장려하는 원칙이다.
    
    - 소프트웨어를 개발할 때 요구사항은 자주 바뀐다. 세부 구현을 숨김으로 프로그램의 어떤 부분을 바꿨을 때 다른 부분까지 영향을 미칠 가능성을 줄일 수 있다. 즉 코드를 관리하고 보호하는 데 유용한 원칙이다.
    
    - 특정 코드 조각이 애플리케이션의 다른 부분과 고립된 캡슐화된 코드의 내부적인 변화가 외부에 영향을 미칠 가능성이 줄어든다.
    
    - 자바에서는 클래스 내의 컴포넌트에 적절하게 private 키워드를 사용했는지를 기준으로 컴파일러를 이용해 캡슐화를 확인할 수 있다. 하지만 자바 9 이전까지는 클래스와 패키지가 의도된 대로 공개되었는지를 컴파일러로 확인할 수 있는 기능이 없었다.
    

> 1️⃣ 관심사 분리와 정보 은닉은 추론하기 쉬운 소프트웨어를 만드는 중요한 두 가지 원칙이다.

2️⃣ 자바 9 이전에는 각각의 기능을 담당하는 패키지, 클래스, 인터페이스로 모듈화를 구현했는데 효과적인 캡슐화를 달성하기에는 역부족이었다.
> 

## 자바 모듈 시스템을 설계한 이유

자바는 클래스, 패키지, JAR 세 가지 수준의 코드 그룹화를 제공한다. 클래스와 관련해 자바는 접근 제한자와 캡슐화를 지원했다. 하지만 패키지와 JAR 수준에서는 캡슐화를 거의 지원하지 않았다.

### 모듈화의 한계

- 제한된 가시성 제어
    - 자바는 정보를 감출 수 있는 접근자를 제공한다. public, protected, 패키지 수준, private
    - 패키지 간의 가시성 어떻게 제어할까?
        - 한 패키지의 클래스와 인터페이스를 다른 패키지로 공개하려면 public으로 선언
        - 이들의 클래스와 인터페이스는 모두에게 공개되는 것
        - 기본 구현을 제공하는 의미로 사용되는 “impl”이라는 문자열을 가진 패키지와 같은 곳에서 사용자가 이 내부 구현을 마음대로 사용할 수 있는 문제가 발생한다.
        - 코드가 노출되었으므로 위험에 더 많이 노출될 수 있음.
- 클래스 경로
    - 애플리케이션을 번들하고 실행하는 과정 : 클래스를 모두 컴파일한 다음 보통 한 개의 평범한 JAR 파일에 넣고 클래스 경로에 이 **JAR** 파일을 추가해 사용할 수 있다. 그러면 JVM이 동적으로 **클래스 경로**에 정의된 클래스를 필요할 때 읽는다.
    
    - 클래스 경로에는 같은 클래스를 구분하는 버전 개념이 없다.
        - ex) 파싱 라이브러리의 JSONParser 클래스를 지정할 때 버전 1.0을 사용하는지 버전 2.0을 사용하는지 지정할 수가 없으므로 클래스 경로에 두 가지 버전의 같은 라이브러리가 존재할 때 어떤 일이 일어날지 예측할 수 없다.
        - 다양한 컴포넌트가 같은 라이브러리의 다른 버전을 사용하는 상황이 발생할 수 있는 큰 애플리케이션에서 이런 문제가 두드러진다.
        
    - 클래스 경로는 명시적인 의존성을 지원하지 않는다.
        - 각각의 JAR 안에 있는 모든 클래스는 classes라는 한 주머니로 합쳐진다.
        - 즉 한 JAR가 다른 JAR에 포함된 클래스 집합을 사용하라고 명시적으로 의존성을 정의하는 기능을 제공하지 않는다.
        - 이 상황에서 클래스 경로 때문에 어떤 일이 일어나는지 파악하기 어렵고 다음과 같은 의문이 들 수 있다. 빠진게 있는가???? 충돌이 있는가???
        - 메이븐이나 그레이들 같은 빌드 도구는 이런 문제를 해결하는 데 도움을 준다.

### 거대한 JDK

- 자바 개발 키트(JDK)는 자바 프로그램을 만들고 실행하는 데 도움을 주는 도구의 집합이다.
- 가장 익숙한 도구로 자바 프로그램을 컴파일하는 javac, 자바 애플리케이션을 로드하고 실행하는 java, 런타임 지원을 제공하는 JDK 라이브러리, 컬렉션, 스트림 등이 있다.
- 시간이 흐르면서 발전하고 덩치가 많이 커졌다. 많은 기술들이 추가되었다가 사장되기를 반복했다.
- 대표적인 예시로 CORBA를 들 수 있는데 CORBA를 애플리케이션에 사용하는지와 관계없이 CORBA의 클래스는 JDK에 포함되었다. 이는 나중에 모바일에서 실행되는 애플리케이션이나 JDK 전부를 필요로 하지 않는 클라우드에서 문제가 되었다.
    - CORBA?
        
        **공통 객체 요구 매개자 구조**(Common Object Request Broker Architecture; **CORBA**
        , 코바)는 OMG에서 정의한 규격으로서 소프트웨어 컴포넌트들을 언어와 사용환경에 대한 제약이 없는 통합을 위한 표준을 지칭한다.
        
        - CORBA는 애플리케이션들끼리 어느 위치든, 누가 만들었든 상관없이 상호간 통신을 보장하고 분산 객체 간의 상호 운용을 위한 통신 미들웨어 역할을 하며, 분산 객체 소프트웨어의 기본 틀로서 서비스를 제공하는 부분과 제공받는 부분간의 투명한 정보 교환이 가능하도록 하며 분산 환경에서 응용 소프트웨어를 쉽게 개발할 수 있도록 지원한다.
        - 분산 환경에서 클라이언트와 서버 간의 인터페이스만 정의되면 이들 서로 간의 서비스 요구나 결과 값의 전달이 하부 통신 메커니즘에 반영될 수 있다.
        - CORBA를 이용한 응용 소프트웨어 개발은 각종 투명성이 보장되기 때문에 사용자의 특정 응용 업무 개발 환경에 적합하고 개발 과정이 간단하고 효율적이다.
- JDK에서 필요한 부분만 골라 사용 + 클래스 경로를 쉽게 유추 가능 + 강력한 캡슐화를 제공할 새로운 건 축 구조가 필요

> 1️⃣ 클래스 경로 지옥 문제는 애플리케이션의 의존성을 추론하기 더욱 어렵게 만들었다.

2️⃣ 자바 9 이전의 JDK는 거대했으며 높은 유지 비용과 진화를 방해하는 문제가 존재했다.
> 

## 자바 모듈

- 자바 8은 모듈이라는 새로운 자바 프로그램 구조 단위를 제공한다. 모듈은 module이라는 새 키워드에 이름과 바디를 추가해서 정의한다. 모듈 디스크립터는 module-info.java라는 특별한 파일에 저장된다.
    - module-info.java 파일은 모듈 디스크립터로 모듈의 소스 코드 파일 루트에 위치해야 하며
        
        모듈의 의존성 그리고 어떤 기능을 외부로 노출할지를 정의한다.
        

- 모듈 디스크립터는 보통 패키지와 같은 폴더에 위치하며 한 개 이상의 패키지를 서술하고 캡슐화할 수 있지만 단순한 상황에서는 이들 패키지 중 한 개만 외부로 노출시킨다.
    
    ![Untitled](CHAPTER%2014%20%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%20%E1%84%86%E1%85%A9%E1%84%83%E1%85%B2%E1%86%AF%20%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%208e41be8daccc42f8936fa8e9f5b82990/Untitled.png)
    

![여러 모듈의 예](CHAPTER%2014%20%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%20%E1%84%86%E1%85%A9%E1%84%83%E1%85%B2%E1%86%AF%20%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%208e41be8daccc42f8936fa8e9f5b82990/Untitled%201.png)

여러 모듈의 예

- 모듈 A는 pkgD를 사용할 수 있을까?

> 1️⃣ 자바 9에서는 새로운 모듈 시스템을 제공하는데 module-info.java 파일은 모듈의 이름을 지정하며 필요한 의존성(requires)과 공개 API(exports)를 정의한다.
> 

## 여러 모듈 활용하기

### exports

- exports는 다른 모듈에서 사용할 수 있도록 특정 패키지를 공개 형식으로 만든다.
- 어떤 패키지를 공개할 것인지를 명시적으로 지정함으로 캡슐화를 높일 수 있다.

### requires

requires는 의존하고 있는 모듈을 지정한다. 

기본적으로 의존하는 java.base라는 플랫폼 모듈 외의 다른 모듈을 임포트할 때 requires를 사용한다.

```jsx
module expenses.readers {
		//모듈명 사용
		**requires** java.base;

		//패키지명 사용
		**exports** com.example.expenses.readers;
		**exports** com.example.expenses.readers.file;
		**exports** com.example.expenses.readers.http;
```

- 자바 9에서는 requires와 exports 구문을 이용해 좀 더 정교하게 클래스 접근을 제어할 수 있다.

![Untitled](CHAPTER%2014%20%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%20%E1%84%86%E1%85%A9%E1%84%83%E1%85%B2%E1%86%AF%20%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%208e41be8daccc42f8936fa8e9f5b82990/Untitled%202.png)

- requires transitive, exports to, open, opens, use, provides 등

### 이름 정하기

- 지금까지 expenses.application처럼 모듈과 패키지의 개념이 혼동되지 않도록 단순한 접근 방식을 사용했다. ← 모듈은 여러 패키지를 노출시킬 수 있다.

- 하지만 위와 같은 방법이 아닌 com.iteratrlearning.training 과 같이 역순으로 모듈의 이름을 정하도록 권고하고 있다.

> 1️⃣ requires 구문으로 필요한 다른 모듈을 정의할 수 있다.

2️⃣ exports 구문으로 특정 패키지를 다른 모듈에서 사용할 수 있는 공개 형식으로 지정할 수 있다.

3️⃣ 인터넷 도메인명을 역순으로 사용하는 것이 권장 모듈 이름 규칙이다.
> 

## 자동 모듈

HttpReader를 저수준으로 구현하지 않고 아파치 프로젝트의 httpclient 같은 특화 라이브러리를 사용해 구현한다고 가정하자.

expenses.readers 프로젝트의 module-info.java에 requires 구문을 추가하고 mvn clean package를 실행하면 

→ `[ERROR] module not found: httpclient`

⇒ 의존성 설정 필요(pom.xml 갱신)

![Untitled](CHAPTER%2014%20%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%20%E1%84%86%E1%85%A9%E1%84%83%E1%85%B2%E1%86%AF%20%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%208e41be8daccc42f8936fa8e9f5b82990/Untitled%203.png)

- 메이븐 컴파일러 플러그인은 module-info.java를 포함하는 프로젝트를 빌드할 때 모든 의존성 모듈을 경로에 놓아 적절한 JAR를 내려받고 이들이 프로젝트에 인식되도록 한다.

- httpclient는 자바 모듈로 사용하려는 외부 라이브러리인데 모듈화가 되어 있지 않은 라이브러리다.
- 자바는 JAR를 자동 모듈이라는 형태로 적절하게 변환한다.
- 모듈 경로상에 있으나 module-info 파일을 가지지 않은 모든 JAR는 자동 모듈이 된다.
- 자동 모듈은 암묵적으로 자신의 모든 패키지를 노출시킨다.

> 1️⃣ 모듈 경로에 포함된 JAR 중에 module-info 파일을 포함하지 않는 모든 JAR는 자동 모듈이 된다.

2️⃣ 자동 모듈은 암묵적으로 모든 패키지를 공개한다.

3️⃣ 메이븐은 자바 9 모듈 시스템으로 구조화된 애플리케이션을 지원한다.
>
# CHAPTER 10 람다를 이용한 도메인 전용 언어

발표자: 장현준
스터디일정: 2022/05/26 오후 6:00
주차별: 6주차
참여자: 권윤옥, 남채린, 이수환, 이승민, 장현준

<aside>
💡 이 장의 내용
1. 도메인 전용 언어란 무엇이며 어떤 형식으로 구성되는가?
2. DSL을 API에 추가할 때의 장단점
3. JVM에서 활용할 수 있는 자바 기반 DSL을 깔끔하게 만드는 대안
4. 최신 자바 인터페이스와 클래스에 적용된 DSL에서 배움
5. 효과적인 자바 기반 DSL을 구현하는 패턴과 기법
6. 이들 패턴을 자바 라이브러리와 도구에서 얼마나 흔히 사용하는가?

</aside>

# DSL(domain specific language)이란?

- 특정 영역을 타겟하고 있는 언어를 말함

→ 예를 들어 SQL! DB의 데이터를 참조하기 위해 날리는 query는 말 그대로 `DB에 데이터를 참조하기 위한목적` 으로만 사용되며 SQL로 웹 애플리케이션 서버를 만드는 것은 불가능하다.
    반면 JAVA는 SQL을 만들어 낼 수도 있고(사실… SQL은 특정한 문법을 가진 문자열이기 때문) 웹 애플리케이션 서버를 만들 수 도있고, 그 외 원하는 모든 것을 만들어 낼 수 있다. `SQL처럼 어떤 목적이 있고 그 목적만 달성할 수 있는 언어` 를 DSL이라고 한다.

- 작은, 범용이 아니라 특정 도메인을 대상으로 만들어진 특수 프로그래밍 언어이다!

### *추가적으로 DSL의 정의

```
DSL은 특정 비즈니스 도메인의 문제를 해결하려고 만든, 작은, 범용이 아닌 특정 도메인을 대상으로 만들어진 특수 프로그래밍 언어다.
예를 들어 쇼핑몰 플랫폼을 개발한다고 가정했을 때, 비지니스 도메인에는 상품을 결제하고 배송처리와 같은 개념이 포함된다.
DSL에란 특정 비즈니스 도메인을 인터페이스로 만든 API라고 생각할 수 있다.(자바 8에서는 Stream, Collector 등 여러 가지 작은 DSL들이 추가되었다.)
자바에서는 도메인을 표현할 수 있는 클래스와 메서드 집합이 필요하다.
```

# 도메인 전용 언어

- DSL은 특정 비즈니스 도메인의 문제를 해결하려고 만든 언어라고도 볼 수 있다.

### 예를 들어보자

- 회계 전용 소프트웨어 애플리케이션을 개발한다고 했을 때 이 상황에서 비즈니스 도메인에는 통장 입출금 내역서, 계좌 통합 같은 개념이 포함된다. `이런 문제를 표현할 수 있는 DSL을 만들 수 있다.`

### DSL 맛보기

```kotlin
inline fun <reified T : Any> httpRequest(requestBlock: HttpRequest.() -> Unit): T {
    val request = HttpRequest().also { requestBlock(it) }
    // Execute http request
    // Parse response
    return T::class.primaryConstructor?.call(200, "OK") ?: throw IllegalStateException()
}
```

### 특징

- `의사 소통의 왕` : 우리의 코드의 의도가 명확히 전달되어야 하며, 프로그래머가 아닌 사람도 이해할 수 있어야 한다. 이런 방식으로 코드가 비즈니스 요구사항에 부합하는지 확인 할 수 있다.
- `한 번 코드를 구현하지만 여러 번 읽는다` : 가독성은 유지보수의 핵심이라고 할 수 있다. 즉 항상 우리의 동료가 쉽게 이해할 수 있도록 코드를 구현해야함.

# DSL의 장점과 단점

### 장점

1. `간결함` : API는 비즈니스 로직을 간편하게 캡슐화하므로 반복을 피할 수 있고 코드를 간결하게 만들 수 있다.
2. `가독성` : 도메인 영역의 용어를 사용하므로 비 도메인 전문가도 코드를 쉽게 이해할 수 있다. 결과적으로 다양한 조직 구성원 간에 코드와 도메인 영역이 공유될 수 있다.
3. `유지보수` : 잘 설계된 DSL로 구현한 코드는 쉽게 유지보수하고 바꿀 수 있다. 유지보수는 비즈니스 관련 코드 즉 가장 비번히 바뀌는 애플리케이션 부분에 특히 중요하다.
4. `높은 수준의 추상화` : DSL은 도메인과 같은 추상화 수준에서 동작하므로 도메인의 문제와 직접적으로 관련되지 않은 세부 사항을 숨김
5. `집중` : 비즈니스 도메인의 규칙을 표현할 목적으로 설계된 언어이므로 프로그래머가 특정 코드에 집중 할 수 있음
6. `관심사 분리` : 지정된 언어로 비즈니스 로직을 표현함으로 애플리케이션의 인프라구조와 관련된 문제와 독립적으로 비즈니스 관련된 코드에서 집중하기가 용이함.

### 단점

1. `DSL 설계의 어려움` : 간결하게 제한적인 언어에 도메인 지식을 담는 것이 쉬운 작업은 아니다.
2. `개발 비용` : 코드에 DSL을 추가하는 작업은 초기 프로젝트에 많은 비용과 시간이 소모되는 작업이다. 또한 DSL 유지보수와 변경은 프로젝트에 부담이다.
3. `추가 우회 계층` : DSL은 추가적인 계층으로 도메인 모델을 감싸며 이 때 계층을 최대한 작게 만들어 선능 문제 회피해야한다.
4. `새로 배워야 하는 언어` , `호스팅 언어 한계`

# JVM에서의 DSL의 카테고리

- 내부 DSL : 순수 자바 코드 (호스팅 언어 기반)
- 외부 DSL :  호스팅 언어와는 독립적인 자체 문법을 가짐
- 다중 DSL : 스칼라, 그루비 → 자바가 아니지만 JVM에서 실행되며 더 유연하게 코드를 작성할 수 있는 언어

### 내부 DSL

- 우리는 자바를 사용하고 자바를 공부하기 때문에 우리에게는 `내부 DSL` 은 자바로 구현한 DSL을 의미. 자바는 조금 클래식하고 유연성이 떨어지는 문법 때문에 `읽기 쉽고` `간단하고` `표현력` 있는 DSL을 만드는 것이 한계가 있었지만, `람다 표현식` 이 등장하면서 어느정도 해결 되었다.

```java
List<String> number = Arrays.asList("one", "two", "three");
numbers.forEach( new Consumer<String>() {
	@Override
	public void accept( String s ) {
		System.out.println(s);
	}
});

                    ⏬

numbers.forEach(s -> System.out.println(s));
```

- 기존 자바  언어를 이용하면 외부 DSL에 비해 새로운 패턴과 기술을 배워 DSL을 구현하는 노력이 현저하게 줄어든다.
- 순수 자바로 DSL을 구현하면 나머지 코드와 함께 DSL을 컴파일 가능. 그래서 추가 비용x
- 기존 자바의 IDE를 이용해서 자동 완성, 리팩터링 같은 기능을 그대로 사용할 수 있다.

### 다중 DSL

- 최근 JVM에서 실행되는 언어는 100개가 넘고, 스칼라, 루비, JRuny, Jython 같은 언어도 JVM의 프로그래밍 언어이다. 그리고 많이 알려진 코틀린도 스칼라와 호환성을 유지하면서 쉽게 배울 수 있는 새 언어이다.

```scala
def times(i: Int, f: => Unit): Unit = {
	f //f 함수 실행
	if (i>1) times(i - 1, f) //횟수가 양수면 쇳수를 감소시켜 재귀적으로 times를 실행한다.
}

//실행 방법
3 times {
	println("Hello World");
}
```

- 위의 스칼라 코드를 봤을 때 자바로는 비슷한 결과를 얻긴 어렵다. 이는 누가 더 DSL 친화적인지를 명확히 보여준다. 하지만 다음과 같은 불편함도 있다.
    - 지식을 다시 공부해야한다.
    - 두 개 이상의 언어가 혼재하므로 여러 컴파일로 소스를 빌드해야함.
    

### 외부 DSL

- 자신만의 문법과 구문으로 새 언어를 설계해야한다. 새 언어를 파싱하고, 파서의 결과를 분석하고, 외부 DSL을 실행할 코드를 만들어야한다.

# 최신 자바 API의 작은 DSL

```java
Collections.sort(persons, new Comparator<Person>() {
	public int compare(Person p1, Person p2) {
		return p1.getAge() - p2.getAge();
	}
});
                 ⏬
Collections.sort(people, (p1, p2) -> p1.getAge() - p2.getAge());
또는 
Collections.sort(persons, comparing(p -> p.getAge())));
```

# 스트림 API는 컬렉션을 조작하는 DSL

- stream 인터페이스는 네이티브 자바 API에 작은 내부 DSL을 적용한 좋은 예이다.

```java
List<String> errors = new ArrayList<>();
int errorCount = 0;
BufferedReader bufferedReader
	= new BufferedReader(new FileReader(fileName));
String line = bufferedReader.readLine(0;
while(errorCount < 40 && line != null) {
	if (line.startsWith("ERROR")) {
		errors.add(line);
		errorCount++;
	}
	line = bufferedReader.readLine();
}
```

```java
List<String> errors = Files.lines(Path.get(fileName))
													 .filter(line -> line.startsWith("ERROR"))
													 .limit(40)
													 .collect(toList());
```

- stream에서 제공하는 DSL을 사용하여 코드 리팩터링

# 그렇다면 자바 DSL의 기법과 패턴은 무엇이 있을까?

- 메서드 체인 → builder 패턴
- 중첩 함수
    - 다른 함수 안에 함수를 이용해 도메인 모델을 만드는 것.
    
    ```java
    Order order = order("BigBank",
    										buy(80, 
    												stock("IBM", on("NYSE")), at(125.00)),
    										sell(50,
    												stock("GOOGLE", on("NASDAQ")), at(375.00))
    										);
    ```
    
- 람다를 이용한 함수 시퀀싱
    
    ```java
    Order order = order( o -> {
    		o.forCustomer( "BigBank" );
    		o.buy( t -> {
    				t.quantity( 80 );
    				t.price( 125.00 );
    				t.stock( s -> {
    						s.symbol( "IBM" );
    						s.market( "NYSE" );
    				});
    });
    ```
    
- 조합하기
    
    ```java
    Order order = forCustomer( "BigBank", // 최상위 수준 주문의 속성을 지정하는 중첩 함수
    													buy( t -> t.quantity( 80 ) // 한 개의 주문을 만드는 람다 표현식
    																		 .stock( "IBM" ) //거래 객체를 만드는 람다 표현식 바디의 메서드 체인
    																		 .on( "NYSE" )
    																		 .at( 125.00 )),
    
    													sell( t -> t.quantity( 50 )
    																		 t.stock( "GOOGLE") 
    ....
    ```
    
    | 패턴이름 | 장점 | 단점 |
    | --- | --- | --- |
    | 메서드 체인 | - 메서드 이름이 키워드 인수 역할을 한다.
    - 선택형 파라미터와 잘 동작한다.
    - DSL 사용자가 정해진 순서로 메서드를 호출 하도록 강제할 수 있다.
    - 문법적 잡음을 최소화한다. | - 구현이 장황하다.
    - 빌드를 연결하는 접착 코드가 필요하다.
    - 들여쓰기 규칙으로만 도메인 객체 계층을 정의한다. |
    | 중첩 함수 | - 구현의 장황함을 중일 수 있다.
    - 함수 중첩으로 도메인 객체 계층을 반영한다. | - 정적 메서드의 사용이 빈번하다.
    - 이름이 아닌 위치로 인수를 정의한다.
    - 선택형 파라미터를 처리할 메서드 오버로딩이 필요함. |
    | 람다를 이용한 함수 시퀀싱 | - 선택형 파라미터와 잘 동작한다.
    - 정적 메서드를 최소화하거나 없앨 수 있다.
    - 빌더 접착코드 x | - 구현이 장황함
    - 람다 표현식으로 인한 문법적 잡음이 DSL에 존재 |
    
    # 정리하며….
    
    - DSL은 크게 `내부적(DSL이 사용될 애플리케이션을 개발한 언어) DSL`과 `외부적 (직접 언어를 설계해 사용) DSL`로 분류할 수 있다. `내부적 DSL`은 개발노력이 적게들지만, 호스팅 언어의 문법 제약을 받는다. `외부적 DSL`은 높은 유연성을 제공하지만 구현하기가 까다롭다.
    - JVM에서 이용할 수 있는 `스칼라`, `그루비`등의 다른 언어로 `다중DSL`을 개발 할 수 있다. 이들 언어는 자바보다는 유연하며 간결하지만 자바와 통합하려면 빌드과정이 복잡하고 자바와 호환문제가 발생할 수 있음
    - 자바의 장황함과 문법적 엄격함 때문에 자바는 `내부적DSL`을 개발하는 언어로는 적합 x. 하지만 자바 8의 람다 표현식과 메서드 참조 덕분에 많이 개선되었다.